---------------------------------------------------------------------------------------
-- Control_V1: Main controller of design version 1:
-- Generates START signal when button(0) is pressed. 
-- Reades from switches and forms the bus x_t
-- Author: Josep Altet. Date: 12-02-2019.
-- Electronic System Design for Communications - ESDC - ETSTB. UPC. Barcelona.
----------------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;


entity control_v1 is
  port( clk_25, done 	: in std_logic;
		x_t				: out std_logic_vector(9 downto 1);
		y_t				: out std_logic_vector(8 downto 1);
		color_t 		: out std_logic_vector(2 downto 0);
		start			: out std_logic;
		sw, btn 		: in std_logic_vector(3 downto 0) );
end control_v1;

architecture functional of control_v1 is
  -- State definition:
  type state_control is (wait_b0, b0_pressed, wait_erase, write_new, wait_write, b0_releassed);
  
  -- output of register state:
  signal st : state_control;
  
  -- Output of internal registers to store data:
  signal old_sw : std_logic_vector(3 downto 0) := "0000";
  signal new_sw : std_logic_vector(3 downto 0);
  
  -- Control signals
  signal ld_color_white, ld_color_red, ld_old, ld_new, ld_x_old, ld_x_new : std_logic;
  
   Begin
  -- y_t is hardware fixed. 
  y_t <= "01000000";  -- VALUE = 64
 
 -- Control State Machine
 -- Waits for bo to be pressed. When it is presed, first the square is erased from memory.
 -- When done is received, a new square is stored on the memory.
 -- This VHDL file shows another way of describing a design compared to wr_memory.vhd
 -- There is one process to describe the control unit behavior.
 -- There is another process to describe all the hardware present in the process unit.
 -- The control signals are specifically described.
 -- This VHDL style is closer to the real hardware implemented... but it is longer to write. 
 
	process(clk_25)
	Begin
		if (clk_25'event and clk_25='1') then
			case st is
				when wait_b0 =>
					if(btn(0) = '1') then 
						st <= b0_pressed;
					end if;
				when b0_pressed =>
					st <= wait_erase;
				when wait_erase =>
					if (done = '1') then
						st <= write_new;
					end if;
				when write_new =>
					st <= wait_write;
				when wait_write =>
					if (done = '1') then
						st <= b0_releassed;
					end if;
				when b0_releassed =>
					if (btn(0) = '0') then
						st <= wait_b0;
					end if;
			End Case;
		End If;
	End Process;
	
-- Control signals generated by the control unit
ld_new <= '1' when st = b0_pressed else '0';
ld_old <= '1' when st = write_new else '0';
ld_color_white <= '1' when st = b0_pressed else '0';
ld_color_red <= '1' when st = write_new else '0';
ld_x_old <= '1' when st = b0_pressed else '0';
ld_x_new <= '1' when st = write_new else '0';
start <= '1' when (st=b0_pressed) or (st=write_new) else '0'; 
			
-- Process Unit. All hardware elements are described with just one process.
-- Implementation of four registers.									 
				 
	process(clk_25)
	Begin
		if (clk_25'event and clk_25='1') then
			-- color_t is the output of a register. Only two possible output values
			if ld_color_white = '1' then
				color_t <= "000";
			elsif ld_color_red = '1' then
				color_t <= "100";
			end if;
			
			-- old_sw 
			if ld_old= '1' then
				old_sw <= new_sw;
			end if;
			
			-- new_sw
			if ld_new = '1' then
				new_sw <= sw;
			end if;
			
			-- Address construction
			if ld_x_old = '1' then
				x_t <= '0' & old_sw & "0000";
			elsif ld_x_new = '1' then
				x_t <= '0' & new_sw & "0000";
			end if;
		End If;
	End Process;
End;
						
			
				
				
				